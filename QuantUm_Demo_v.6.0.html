<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Lab — Точный квантовый эмулятор (5 кубитов)</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2d2d2d;
            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --accent-blue: #0a84ff;
            --accent-purple: #bf5af2;
            --accent-green: #30d158;
            --accent-red: #ff453a;
            --accent-yellow: #ffd60a;
            --accent-orange: #ff9f0a;
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 40px);
            box-sizing: border-box;
        }
        
        .panel {
            background-color: var(--bg-panel);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1, h2, h3 {
            color: var(--text-primary);
            font-weight: 500;
            margin-top: 0;
        }
        
        h1 {
            font-size: 22px;
            border-bottom: 1px solid #444;
            padding-bottom: 12px;
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 16px;
        }
        
        h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }
        
        button {
            background-color: var(--accent-blue);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
            margin-right: 8px;
            margin-bottom: 8px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 500;
        }
        
        button:hover {
            background-color: #0071e3;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background-color: var(--bg-panel);
            border: 1px solid #444;
            color: var(--text-primary);
        }
        
        button.secondary:hover {
            background-color: #3a3a3a;
        }
        
        button.danger {
            background-color: var(--accent-red);
        }
        
        button.danger:hover {
            background-color: #d30f45;
        }
        
        button.success {
            background-color: var(--accent-green);
        }
        
        button.success:hover {
            background-color: #28a745;
        }
        
        .gate-btn {
            background-color: #333;
            border: 1px solid #444;
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 4px;
            border-radius: 8px;
            transition: var(--transition);
        }
        
        .gate-btn:hover {
            background-color: #3a3a3a;
            transform: scale(1.05);
        }
        
        .gate-btn.active {
            background-color: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .visualization {
            width: 100%;
            height: 500px;
            background-color: #000;
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }
        
        .qubit-line {
            position: absolute;
            height: 1px;
            width: 100%;
            background-color: #444;
            transition: var(--transition);
        }
        
        .qubit-line.selected {
            background-color: rgba(10, 132, 255, 0.3);
            height: 2px;
        }
        
        .qubit-label {
            position: absolute;
            left: 10px;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
        }
        
        .qubit-circle {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: var(--transition);
            cursor: pointer;
        }
        
        .gate {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(10, 132, 255, 0.2);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .gate:hover {
            transform: translate(-50%, -50%) scale(1.1);
            background-color: rgba(10, 132, 255, 0.3);
        }
        
        .entanglement-line {
            position: absolute;
            background-color: var(--accent-green);
            width: 2px;
            z-index: 5;
            transform: translateX(-50%);
        }
        
        .control-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: var(--accent-blue);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .swap-marker {
            position: absolute;
            color: var(--accent-red);
            font-size: 20px;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .measure-gate {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 69, 58, 0.2);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .probabilities {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .prob-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .prob-label {
            width: 60px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
        }
        
        .prob-bar {
            height: 20px;
            background-color: var(--accent-purple);
            border-radius: 4px;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 5px;
            font-size: 10px;
            color: white;
            min-width: 30px;
        }
        
        select, input {
            background-color: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid #444;
            border-radius: var(--border-radius);
            padding: 8px 12px;
            margin-bottom: 16px;
            width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: var(--transition);
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .state-vector {
            font-family: 'SF Mono', monospace;
            background-color: #000;
            padding: 12px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            white-space: pre;
            font-size: 12px;
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .gate-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .history-item {
            padding: 8px;
            border-bottom: 1px solid #444;
            font-size: 13px;
            font-family: 'SF Mono', monospace;
            display: flex;
            justify-content: space-between;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .bloch-sphere {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            position: relative;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: var(--transition);
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .tab:hover {
            color: var(--text-primary);
        }
        
        .tab.active {
            color: var(--accent-blue);
            border-bottom: 2px solid var(--accent-blue);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .noise-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .noise-control {
            margin-bottom: 10px;
        }
        
        .noise-control label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .complex-number {
            display: inline-block;
            margin-right: 10px;
            font-family: 'SF Mono', monospace;
        }
        
        .analysis-value {
            font-family: 'SF Mono', monospace;
            color: var(--accent-blue);
            margin-left: 5px;
        }
        
        .example-btn {
            width: 100%;
            margin-bottom: 8px;
            text-align: left;
            padding: 10px 16px;
            display: flex;
            align-items: center;
        }
        
        .example-btn i {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .bloch-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .bloch-item {
            flex: 1;
            min-width: 200px;
        }
        
        .bloch-title {
            text-align: center;
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-panel);
            padding: 8px 20px;
            font-size: 12px;
            color: var(--text-secondary);
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
        }
        
        .status-item {
            margin-left: 15px;
        }
        
        .status-item i {
            margin-right: 5px;
        }
        
        .gate-area {
            position: relative;
            height: 100%;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        /* Адаптивность */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .right-panel {
                order: -1;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="panel">
                <h1><i class="fas fa-atom"></i> Quantum Lab (5 кубитов)</h1>
                
                <div class="tab-container">
                    <div class="tab active" data-tab="gates"><i class="fas fa-sliders-h"></i> Гейты</div>
                    <div class="tab" data-tab="noise"><i class="fas fa-wave-square"></i> Шумы</div>
                    <div class="tab" data-tab="examples"><i class="fas fa-project-diagram"></i> Примеры</div>
                    <div class="tab" data-tab="analysis"><i class="fas fa-chart-line"></i> Анализ</div>
                </div>
                
                <div class="tab-content active" id="gates-tab">
                    <div class="controls">
                        <button id="reset" class="danger"><i class="fas fa-redo"></i> Сброс</button>
                        <button id="measure" class="success"><i class="fas fa-ruler"></i> Измерить</button>
                        <button id="undo" class="secondary"><i class="fas fa-undo"></i> Отменить</button>
                        <button id="normalize-btn" class="secondary"><i class="fas fa-balance-scale"></i> Нормировать</button>
                    </div>
                    
                    <h3>Одиночные кубиты:</h3>
                    <div class="controls">
                        <button class="gate-btn" data-gate="h" title="Адамара"><i class="fas fa-h-square"></i></button>
                        <button class="gate-btn" data-gate="x" title="Паули X"><i class="fas fa-x-ray"></i></button>
                        <button class="gate-btn" data-gate="y" title="Паули Y"><i class="fas fa-yin-yang"></i></button>
                        <button class="gate-btn" data-gate="z" title="Паули Z">Z</button>
                        <button class="gate-btn" data-gate="s" title="Фазовый (π/2)">S</button>
                        <button class="gate-btn" data-gate="t" title="π/8">T</button>
                        <button class="gate-btn" data-gate="rx" title="Вращение X">R<sub>x</sub></button>
                        <button class="gate-btn" data-gate="ry" title="Вращение Y">R<sub>y</sub></button>
                        <button class="gate-btn" data-gate="rz" title="Вращение Z">R<sub>z</sub></button>
                    </div>
                    
                    <h3>Двухкубитные:</h3>
                    <div class="controls">
                        <button class="gate-btn" data-gate="cx" title="Управляемое NOT"><i class="fas fa-project-diagram"></i> X</button>
                        <button class="gate-btn" data-gate="cz" title="Управляемое Z"><i class="fas fa-project-diagram"></i> Z</button>
                        <button class="gate-btn" data-gate="swap" title="Обмен"><i class="fas fa-exchange-alt"></i></button>
                    </div>
                    
                    <h3>Трехкубитные:</h3>
                    <div class="controls">
                        <button class="gate-btn" data-gate="ccx" title="Toffoli"><i class="fas fa-project-diagram"></i><i class="fas fa-project-diagram"></i> X</button>
                        <button class="gate-btn" data-gate="cswap" title="Фредкин"><i class="fas fa-project-diagram"></i><i class="fas fa-exchange-alt"></i></button>
                    </div>
                    
                    <div id="angle-controls" style="display: none;">
                        <h3>Параметры вращения:</h3>
                        <input type="range" id="angle-slider" min="0" max="628" step="1" value="314">
                        <span id="angle-value">π</span>
                    </div>
                </div>
                
                <div class="tab-content" id="noise-tab">
                    <h3>Модель шумов</h3>
                    <select id="noise-preset">
                        <option value="none">Без шумов</option>
                        <option value="ibmq">IBMQ (реалистичный)</option>
                        <option value="rigetti">Rigetti (высокие T1/T2)</option>
                        <option value="custom" selected>Кастомные параметры</option>
                    </select>
                    
                    <div class="noise-controls">
                        <div class="noise-control">
                            <label for="t1">T1 (мкс)</label>
                            <input type="number" id="t1" value="50" min="1" step="1">
                        </div>
                        <div class="noise-control">
                            <label for="t2">T2 (мкс)</label>
                            <input type="number" id="t2" value="70" min="1" step="1">
                        </div>
                        <div class="noise-control">
                            <label for="gate-error">Ошибка гейта (%)</label>
                            <input type="number" id="gate-error" value="1" min="0" max="100" step="0.1">
                        </div>
                        <div class="noise-control">
                            <label for="readout-error">Ошибка измерения (%)</label>
                            <input type="number" id="readout-error" value="2" min="0" max="100" step="0.1">
                        </div>
                    </div>
                    
                    <button id="apply-noise" class="secondary"><i class="fas fa-check-circle"></i> Применить параметры</button>
                    
                    <h3 style="margin-top: 20px;">Типы шумов:</h3>
                    <div class="controls">
                        <button class="secondary" id="toggle-relaxation"><i class="fas fa-clock"></i> Релаксация</button>
                        <button class="secondary" id="toggle-dephasing"><i class="fas fa-wave-square"></i> Дефазировка</button>
                        <button class="secondary" id="toggle-depolarizing"><i class="fas fa-atom"></i> Деполяризация</button>
                    </div>
                </div>
                
                <div class="tab-content" id="examples-tab">
                    <h3>Примеры схем</h3>
                    <button class="example-btn secondary" id="example-bell">
                        <i class="fas fa-link"></i> Цепочка Белла
                    </button>
                    <button class="example-btn secondary" id="example-deutsch">
                        <i class="fas fa-brain"></i> Алгоритм Дойча
                    </button>
                    <button class="example-btn secondary" id="example-teleport">
                        <i class="fas fa-paper-plane"></i> Телепортация
                    </button>
                    <button class="example-btn secondary" id="example-grover">
                        <i class="fas fa-search"></i> Гровера (2 кубита)
                    </button>
                    <button class="example-btn secondary" id="example-qft">
                        <i class="fas fa-wave-square"></i> Квантовое преобразование Фурье
                    </button>
                    
                    <h3 style="margin-top: 20px;">Пошаговое выполнение:</h3>
                    <div class="controls">
                        <button class="secondary" id="step-back" disabled><i class="fas fa-step-backward"></i></button>
                        <button class="secondary" id="step-forward" disabled><i class="fas fa-step-forward"></i></button>
                        <button class="secondary" id="run-all"><i class="fas fa-play"></i> Выполнить все</button>
                    </div>
                </div>
                
                <div class="tab-content" id="analysis-tab">
                    <h3>Анализ состояния</h3>
                    <div id="purity-display">Чистота: <span class="analysis-value">-</span></div>
                    <div id="entropy-display">Энтропия фон Неймана: <span class="analysis-value">-</span></div>
                    <div id="entanglement-display">Запутанность: <span class="analysis-value">-</span></div>
                    <div id="fidelity-display">Фиделитет с идеальным: <span class="analysis-value">-</span></div>
                    <div id="normalization-display">Нормировка: <span class="analysis-value">1.0000</span></div>
                    
                    <h3 style="margin-top: 20px;">Сферы Блоха:</h3>
                    <div class="bloch-container" id="bloch-spheres">
                        <!-- Будет заполнено JavaScript -->
                    </div>
                </div>
                
                <div class="gate-history" id="gate-history">
                    <h3><i class="fas fa-history"></i> История операций</h3>
                    <div id="history-items">
                        <!-- Filled by JS -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="panel">
                <h1><i class="fas fa-project-diagram"></i> Визуализация схемы</h1>
                <div class="visualization" id="visualization">
                    <div class="gate-area" id="gate-area">
                        <!-- Qubit lines and gates will be added here -->
                    </div>
                </div>
                
                <div style="display: flex; gap: 20px; margin-top: 20px;">
                    <div style="flex: 1;">
                        <h3><i class="fas fa-chart-bar"></i> Вероятности состояний</h3>
                        <div class="probabilities" id="probabilities">
                            <!-- Filled by JS -->
                        </div>
                    </div>
                    
                    <div style="flex: 1;">
                        <h3><i class="fas fa-vector-square"></i> Вектор состояния</h3>
                        <div class="state-vector" id="state-vector">
                            |ψ⟩ = |00000⟩
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="status-bar">
        <div><i class="fas fa-question-circle"></i> <span id="status-message">Готов к работе. Выберите гейт и кубиты.</span></div>
        <div>
            <span class="status-item"><i class="fas fa-bolt"></i> <span id="qubit-count">5</span> кубитов</span>
            <span class="status-item"><i class="fas fa-memory"></i> <span id="state-size">32</span> состояний</span>
            <span class="status-item"><i class="fas fa-layer-group"></i> <span id="gate-count">0</span> гейтов</span>
        </div>
    </div>

    <script>
        // Точная реализация комплексных чисел
        class Complex {
            constructor(real, imag = 0) {
                this.re = real;
                this.im = imag;
            }
            
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            
            subtract(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            
            multiply(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            
            scale(scalar) {
                return new Complex(this.re * scalar, this.im * scalar);
            }
            
            conjugate() {
                return new Complex(this.re, -this.im);
            }
            
            magnitude() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
            
            phase() {
                return Math.atan2(this.im, this.re);
            }
            
            equals(other, epsilon = 1e-10) {
                return Math.abs(this.re - other.re) < epsilon && 
                       Math.abs(this.im - other.im) < epsilon;
            }
            
            toString() {
                if (this.im === 0) return this.re.toFixed(4);
                if (this.re === 0) return `${this.im.toFixed(4)}i`;
                return `${this.re.toFixed(4)} ${this.im >= 0 ? '+' : '-'} ${Math.abs(this.im).toFixed(4)}i`;
            }
        }

        // Точная реализация матриц плотности
        class DensityMatrix {
            constructor(stateSize) {
                this.size = stateSize;
                this.matrix = Array.from({length: stateSize}, () => 
                    Array.from({length: stateSize}, () => new Complex(0))
                );
            }
            
            fromStateVector(stateVector) {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        this.matrix[i][j] = stateVector[i].multiply(stateVector[j].conjugate());
                    }
                }
                return this;
            }
            
            partialTrace(qubitToTraceOut, numQubits) {
                const keepSize = 1 << (numQubits - 1);
                const result = new DensityMatrix(keepSize);
                
                for (let i = 0; i < keepSize; i++) {
                    for (let j = 0; j < keepSize; j++) {
                        let sum = new Complex(0);
                        
                        for (let k = 0; k < 2; k++) {
                            const row = this.insertBit(i, qubitToTraceOut, k, numQubits);
                            const col = this.insertBit(j, qubitToTraceOut, k, numQubits);
                            sum = sum.add(this.matrix[row][col]);
                        }
                        
                        result.matrix[i][j] = sum;
                    }
                }
                
                return result;
            }
            
            insertBit(num, pos, bit, totalQubits) {
                const mask = (1 << (totalQubits - 1 - pos)) - 1;
                return ((num & ~mask) << 1) | (bit << (totalQubits - 1 - pos)) | (num & mask);
            }
            
            purity() {
                let trace = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        trace += this.matrix[i][j].multiply(this.matrix[j][i]).re;
                    }
                }
                return trace;
            }
            
            vonNeumannEntropy() {
                const eigenvalues = this.jacobiEigenvalues();
                let entropy = 0;
                
                for (const lambda of eigenvalues) {
                    if (lambda > 1e-10) {
                        entropy -= lambda * Math.log2(lambda);
                    }
                }
                
                return entropy;
            }
            
            jacobiEigenvalues(maxIterations = 100, tolerance = 1e-8) {
                const n = this.size;
                const A = Array.from({length: n}, (_, i) => 
                    Array.from({length: n}, (_, j) => new Complex(this.matrix[i][j].re, this.matrix[i][j].im))
                );
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    let maxVal = 0;
                    let p = 0, q = 0;
                    
                    for (let i = 0; i < n; i++) {
                        for (let j = i+1; j < n; j++) {
                            const mag = A[i][j].magnitude();
                            if (mag > maxVal) {
                                maxVal = mag;
                                p = i;
                                q = j;
                            }
                        }
                    }
                    
                    if (maxVal < tolerance) break;
                    
                    const App = A[p][p].re;
                    const Aqq = A[q][q].re;
                    const Apq = A[p][q];
                    
                    const tau = (Aqq - App) / (2 * Apq.magnitude());
                    const t = Math.sign(tau) / (Math.abs(tau) + Math.sqrt(1 + tau*tau));
                    const c = 1 / Math.sqrt(1 + t*t);
                    const s = t * c;
                    
                    for (let k = 0; k < n; k++) {
                        if (k !== p && k !== q) {
                            const Akp = A[k][p];
                            const Akq = A[k][q];
                            
                            A[k][p] = Akp.multiply(new Complex(c)).subtract(Akq.multiply(new Complex(s)));
                            A[p][k] = A[k][p].conjugate();
                            
                            A[k][q] = Akq.multiply(new Complex(c)).add(Akp.multiply(new Complex(s)));
                            A[q][k] = A[k][q].conjugate();
                        }
                    }
                    
                    const AppNew = c*c*A[p][p].re - 2*c*s*Apq.re + s*s*A[q][q].re;
                    const AqqNew = s*s*A[p][p].re + 2*c*s*Apq.re + c*c*A[q][q].re;
                    const ApqNew = new Complex(0);
                    
                    A[p][p] = new Complex(AppNew);
                    A[q][q] = new Complex(AqqNew);
                    A[p][q] = ApqNew;
                    A[q][p] = ApqNew.conjugate();
                }
                
                return A.map((row, i) => row[i].re);
            }
        }

        // Класс для коррекции ошибок
        class ErrorCorrector {
            static applyPauliCorrection(emulator, qubit, type) {
                if (!['x', 'y', 'z'].includes(type.toLowerCase())) {
                    throw new Error(`Недопустимый тип коррекции Паули: ${type}`);
                }
                emulator.applyGate(type.toLowerCase(), [qubit]);
            }
            
            static applyMeasurementCorrection(emulator, qubitIndex, measurementResult) {
                if (measurementResult === 1) {
                    emulator.applyGate('x', [qubitIndex]);
                }
            }
            
            static applyTeleportationCorrections(emulator, measuredQubits) {
                const [q0, q1] = measuredQubits;
                if (q1 === 1) this.applyPauliCorrection(emulator, 2, 'X');
                if (q0 === 1) this.applyPauliCorrection(emulator, 2, 'Z');
            }
        }

        // Основной класс квантового эмулятора
        class QuantumEmulator {
            constructor(numQubits = 5) {
                this.numQubits = numQubits;
                this.stateSize = 1 << numQubits;
                this.stateVector = this.initializeStateVector();
                this.densityMatrix = new DensityMatrix(this.stateSize).fromStateVector(this.stateVector);
                
                // Параметры шумов
                this.noiseParams = {
                    t1: 50,     // microseconds
                    t2: 70,     // microseconds
                    gateError: 0.01,  // 1%
                    readoutError: 0.02, // 2%
                    thermalRelaxation: true,
                    decoherence: true,
                    depolarizing: false
                };
                
                this.currentGate = null;
                this.selectedQubits = [];
                this.measured = false;
                this.gateHistory = [];
                this.rotationAngle = Math.PI;
                this.gateCounter = 0;
                this.qubitPositions = [];
                this.exampleSteps = [];
                this.currentStep = -1;
                
                this.initVisualization();
                this.updateDisplay();
                this.updateStatusBar();
            }
            
            initializeStateVector() {
                const state = new Array(this.stateSize).fill(new Complex(0));
                state[0] = new Complex(1); // Начальное состояние |00...0⟩
                return state;
            }
            
            applyUnitaryOperator(matrix) {
                const newState = new Array(this.stateSize).fill(new Complex(0));
                
                for (let i = 0; i < this.stateSize; i++) {
                    for (let j = 0; j < this.stateSize; j++) {
                        if (!matrix[i][j].equals(new Complex(0))) {
                            newState[i] = newState[i].add(matrix[i][j].multiply(this.stateVector[j]));
                        }
                    }
                }
                
                this.stateVector = newState;
                this.normalizeState();
                this.densityMatrix.fromStateVector(this.stateVector);
            }
            
            normalizeState() {
                let sum = 0;
                for (const amp of this.stateVector) {
                    sum += amp.magnitude() ** 2;
                }
                
                const norm = Math.sqrt(sum);
                if (norm > 1e-10) {
                    this.stateVector = this.stateVector.map(amp => amp.scale(1 / norm));
                }
                
                // Обновляем отображение нормировки
                const normDisplay = document.getElementById('normalization-display');
                if (normDisplay) {
                    normDisplay.querySelector('.analysis-value').textContent = norm.toFixed(4);
                }
                
                return norm;
            }
            
            validateGate(gate, qubits, angle = null) {
                const validGates = ['h', 'x', 'y', 'z', 's', 't', 'rx', 'ry', 'rz', 'cx', 'cz', 'swap', 'ccx', 'cswap'];
                if (!validGates.includes(gate)) {
                    throw new Error(`Неизвестный гейт: ${gate}`);
                }
                
                if (qubits.some(q => q < 0 || q >= this.numQubits)) {
                    throw new Error(`Недопустимый индекс кубита. Допустимый диапазон: 0-${this.numQubits-1}`);
                }
                
                if (['cx', 'cz', 'swap'].includes(gate) && qubits.length !== 2) {
                    throw new Error(`Гейт ${gate} требует 2 кубита`);
                }
                
                if (['ccx', 'cswap'].includes(gate) && qubits.length !== 3) {
                    throw new Error(`Гейт ${gate} требует 3 кубита`);
                }
                
                if (['rx', 'ry', 'rz'].includes(gate) && angle === null) {
                    throw new Error(`Гейт ${gate} требует параметр angle`);
                }
                
                if (this.measured) {
                    throw new Error("Схема уже измерена! Сбросьте для нового эксперимента.");
                }
            }
            
            applyGate(gate, qubits, angle = null) {
                try {
                    this.validateGate(gate, qubits, angle);
                    
                    const prevState = [...this.stateVector];
                    const matrix = this.buildGateMatrix(gate, qubits, angle);
                    this.applyUnitaryOperator(matrix);
                    this.applyNoise();
                    
                    const gateName = angle ? `${gate}(${(angle / Math.PI).toFixed(2)}π)` : gate.toUpperCase();
                    const targets = qubits.map(q => `Q${q}`).join(', ');
                    this.gateHistory.push({
                        gate: gateName,
                        targets: targets,
                        state: prevState
                    });
                    
                    this.updateDisplay();
                    this.updateStatusBar();
                    return true;
                } catch (e) {
                    console.error("Error applying gate:", e);
                    this.showTooltip("Ошибка применения гейта: " + e.message, 3000);
                    return false;
                }
            }
            
            buildGateMatrix(gate, qubits, angle) {
                const matrix = Array.from({length: this.stateSize}, () => 
                    Array(this.stateSize).fill(new Complex(0))
                );
                
                for (let i = 0; i < this.stateSize; i++) {
                    matrix[i][i] = new Complex(1);
                }
                
                switch (gate) {
                    case 'h':
                        this.applySingleQubitMatrix(qubits[0], this.hadamardMatrix(), matrix);
                        break;
                    case 'x':
                        this.applySingleQubitMatrix(qubits[0], this.pauliXMatrix(), matrix);
                        break;
                    case 'y':
                        this.applySingleQubitMatrix(qubits[0], this.pauliYMatrix(), matrix);
                        break;
                    case 'z':
                        this.applySingleQubitMatrix(qubits[0], this.pauliZMatrix(), matrix);
                        break;
                    case 's':
                        this.applySingleQubitMatrix(qubits[0], this.phaseMatrix(Math.PI/2), matrix);
                        break;
                    case 't':
                        this.applySingleQubitMatrix(qubits[0], this.phaseMatrix(Math.PI/4), matrix);
                        break;
                    case 'rx':
                        this.applySingleQubitMatrix(qubits[0], this.rotationXMatrix(angle || this.rotationAngle), matrix);
                        break;
                    case 'ry':
                        this.applySingleQubitMatrix(qubits[0], this.rotationYMatrix(angle || this.rotationAngle), matrix);
                        break;
                    case 'rz':
                        this.applySingleQubitMatrix(qubits[0], this.rotationZMatrix(angle || this.rotationAngle), matrix);
                        break;
                    case 'cx':
                        this.applyControlledGateMatrix(qubits[0], qubits[1], this.pauliXMatrix(), matrix);
                        break;
                    case 'cz':
                        this.applyControlledGateMatrix(qubits[0], qubits[1], this.pauliZMatrix(), matrix);
                        break;
                    case 'swap':
                        this.applySwapGateMatrix(qubits[0], qubits[1], matrix);
                        break;
                    case 'ccx':
                        this.applyToffoliGateMatrix(qubits[0], qubits[1], qubits[2], matrix);
                        break;
                    case 'cswap':
                        this.applyFredkinGateMatrix(qubits[0], qubits[1], qubits[2], matrix);
                        break;
                }
                
                return matrix;
            }
            
            applySingleQubitMatrix(qubit, gateMatrix, targetMatrix) {
                const n = this.numQubits;
                const mask = 1 << (n - 1 - qubit);
                
                for (let i = 0; i < this.stateSize; i++) {
                    const i0 = i & ~mask;
                    const i1 = i | mask;
                    const b = (i & mask) !== 0 ? 1 : 0;
                    
                    for (let j = 0; j < this.stateSize; j++) {
                        const j0 = j & ~mask;
                        const j1 = j | mask;
                        const b2 = (j & mask) !== 0 ? 1 : 0;
                        
                        if (i0 === j0) {
                            targetMatrix[i][j] = gateMatrix[b][b2];
                        }
                    }
                }
            }
            
            applyControlledGateMatrix(control, target, gateMatrix, targetMatrix) {
                const n = this.numQubits;
                const controlMask = 1 << (n - 1 - control);
                const targetMask = 1 << (n - 1 - target);
                
                for (let i = 0; i < this.stateSize; i++) {
                    if ((i & controlMask) === 0) continue;
                    
                    const i0 = i & ~targetMask;
                    const i1 = i | targetMask;
                    const b = (i & targetMask) !== 0 ? 1 : 0;
                    
                    for (let j = 0; j < this.stateSize; j++) {
                        if ((j & controlMask) === 0) continue;
                        
                        const j0 = j & ~targetMask;
                        const j1 = j | targetMask;
                        const b2 = (j & targetMask) !== 0 ? 1 : 0;
                        
                        if (i0 === j0) {
                            targetMatrix[i][j] = gateMatrix[b][b2];
                        }
                    }
                }
            }
            
            applySwapGateMatrix(qubit1, qubit2, targetMatrix) {
                const n = this.numQubits;
                const mask1 = 1 << (n - 1 - qubit1);
                const mask2 = 1 << (n - 1 - qubit2);
                
                for (let i = 0; i < this.stateSize; i++) {
                    const hasQ1 = (i & mask1) !== 0;
                    const hasQ2 = (i & mask2) !== 0;
                    
                    if (hasQ1 !== hasQ2) {
                        const swapped = i ^ mask1 ^ mask2;
                        targetMatrix[i][i] = new Complex(0);
                        targetMatrix[swapped][i] = new Complex(1);
                    }
                }
            }
            
            applyToffoliGateMatrix(control1, control2, target, targetMatrix) {
                const n = this.numQubits;
                const mask1 = 1 << (n - 1 - control1);
                const mask2 = 1 << (n - 1 - control2);
                const targetMask = 1 << (n - 1 - target);
                
                for (let i = 0; i < this.stateSize; i++) {
                    if ((i & mask1) === 0 || (i & mask2) === 0) continue;
                    
                    const i0 = i & ~targetMask;
                    const i1 = i | targetMask;
                    const b = (i & targetMask) !== 0 ? 1 : 0;
                    
                    for (let j = 0; j < this.stateSize; j++) {
                        if ((j & mask1) === 0 || (j & mask2) === 0) continue;
                        
                        const j0 = j & ~targetMask;
                        const j1 = j | targetMask;
                        const b2 = (j & targetMask) !== 0 ? 1 : 0;
                        
                        if (i0 === j0) {
                            targetMatrix[i][j] = this.pauliXMatrix()[b][b2];
                        }
                    }
                }
            }
            
            applyFredkinGateMatrix(control, target1, target2, targetMatrix) {
                const n = this.numQubits;
                const controlMask = 1 << (n - 1 - control);
                const mask1 = 1 << (n - 1 - target1);
                const mask2 = 1 << (n - 1 - target2);
                
                for (let i = 0; i < this.stateSize; i++) {
                    if ((i & controlMask) === 0) continue;
                    
                    const hasQ1 = (i & mask1) !== 0;
                    const hasQ2 = (i & mask2) !== 0;
                    
                    if (hasQ1 !== hasQ2) {
                        const swapped = i ^ mask1 ^ mask2;
                        targetMatrix[i][i] = new Complex(0);
                        targetMatrix[swapped][i] = new Complex(1);
                    }
                }
            }
            
            hadamardMatrix() {
                const sqrt2 = Math.sqrt(2);
                return [
                    [new Complex(1/sqrt2), new Complex(1/sqrt2)],
                    [new Complex(1/sqrt2), new Complex(-1/sqrt2)]
                ];
            }
            
            pauliXMatrix() {
                return [
                    [new Complex(0), new Complex(1)],
                    [new Complex(1), new Complex(0)]
                ];
            }
            
            pauliYMatrix() {
                return [
                    [new Complex(0), new Complex(0, -1)],
                    [new Complex(0, 1), new Complex(0)]
                ];
            }
            
            pauliZMatrix() {
                return [
                    [new Complex(1), new Complex(0)],
                    [new Complex(0), new Complex(-1)]
                ];
            }
            
            phaseMatrix(angle) {
                return [
                    [new Complex(1), new Complex(0)],
                    [new Complex(0), new Complex(Math.cos(angle), Math.sin(angle))]
                ];
            }
            
            rotationXMatrix(angle) {
                const cos = Math.cos(angle/2);
                const sin = Math.sin(angle/2);
                return [
                    [new Complex(cos), new Complex(0, -sin)],
                    [new Complex(0, -sin), new Complex(cos)]
                ];
            }
            
            rotationYMatrix(angle) {
                const cos = Math.cos(angle/2);
                const sin = Math.sin(angle/2);
                return [
                    [new Complex(cos), new Complex(-sin)],
                    [new Complex(sin), new Complex(cos)]
                ];
            }
            
            rotationZMatrix(angle) {
                const cos = Math.cos(angle/2);
                const sin = Math.sin(angle/2);
                return [
                    [new Complex(cos, -sin), new Complex(0)],
                    [new Complex(0), new Complex(cos, sin)]
                ];
            }
            
            applyNoise() {
                if (!this.noiseParams.thermalRelaxation && !this.noiseParams.decoherence && !this.noiseParams.depolarizing) {
                    return;
                }
                
                const originalState = [...this.stateVector];
                let noisyState = [...originalState];
                
                if (this.noiseParams.depolarizing) {
                    noisyState = this.applyDepolarizingNoise(noisyState);
                }
                
                if (this.noiseParams.thermalRelaxation) {
                    noisyState = this.applyThermalRelaxation(noisyState);
                }
                
                if (this.noiseParams.decoherence) {
                    noisyState = this.applyDephasingNoise(noisyState);
                }
                
                this.stateVector = noisyState;
            }
            
            applyDepolarizingNoise(state) {
                const noiseStrength = this.noiseParams.gateError;
                const numQubits = this.numQubits;
                const stateSize = this.stateSize;
                const newState = [...state];
                
                for (let q = 0; q < numQubits; q++) {
                    if (Math.random() < noiseStrength) {
                        const errorType = Math.floor(Math.random() * 3);
                        let errorMatrix;
                        
                        switch (errorType) {
                            case 0: errorMatrix = this.pauliXMatrix(); break;
                            case 1: errorMatrix = this.pauliYMatrix(); break;
                            case 2: errorMatrix = this.pauliZMatrix(); break;
                        }
                        
                        const noisyMatrix = Array.from({length: stateSize}, () => Array(stateSize).fill(new Complex(0)));
                        this.applySingleQubitMatrix(q, errorMatrix, noisyMatrix);
                        
                        const tempState = new Array(stateSize).fill(new Complex(0));
                        for (let i = 0; i < stateSize; i++) {
                            for (let j = 0; j < stateSize; j++) {
                                if (!noisyMatrix[i][j].equals(new Complex(0))) {
                                    tempState[i] = tempState[i].add(noisyMatrix[i][j].multiply(newState[j]));
                                }
                            }
                        }
                        
                        for (let i = 0; i < stateSize; i++) {
                            newState[i] = tempState[i];
                        }
                    }
                }
                
                return newState;
            }
            
            applyThermalRelaxation(state) {
                const t1 = this.noiseParams.t1;
                const dt = 1.0;
                const newState = [...state];
                
                for (let q = 0; q < this.numQubits; q++) {
                    const pReset = 1 - Math.exp(-dt/t1);
                    if (Math.random() < pReset) {
                        const xMatrix = Array.from({length: this.stateSize}, () => Array(this.stateSize).fill(new Complex(0)));
                        this.applySingleQubitMatrix(q, this.pauliXMatrix(), xMatrix);
                        
                        const tempState = new Array(this.stateSize).fill(new Complex(0));
                        for (let i = 0; i < this.stateSize; i++) {
                            for (let j = 0; j < this.stateSize; j++) {
                                if (!xMatrix[i][j].equals(new Complex(0))) {
                                    tempState[i] = tempState[i].add(xMatrix[i][j].multiply(newState[j]));
                                }
                            }
                        }
                        
                        for (let i = 0; i < this.stateSize; i++) {
                            newState[i] = tempState[i];
                        }
                    }
                }
                
                return newState;
            }
            
            applyDephasingNoise(state) {
                const t2 = this.noiseParams.t2;
                const dt = 1.0;
                const newState = [...state];
                
                for (let q = 0; q < this.numQubits; q++) {
                    const pDephase = 1 - Math.exp(-dt/t2);
                    if (Math.random() < pDephase) {
                        const zMatrix = Array.from({length: this.stateSize}, () => Array(this.stateSize).fill(new Complex(0)));
                        this.applySingleQubitMatrix(q, this.pauliZMatrix(), zMatrix);
                        
                        const tempState = new Array(this.stateSize).fill(new Complex(0));
                        for (let i = 0; i < this.stateSize; i++) {
                            for (let j = 0; j < this.stateSize; j++) {
                                if (!zMatrix[i][j].equals(new Complex(0))) {
                                    tempState[i] = tempState[i].add(zMatrix[i][j].multiply(newState[j]));
                                }
                            }
                        }
                        
                        for (let i = 0; i < this.stateSize; i++) {
                            newState[i] = tempState[i];
                        }
                    }
                }
                
                return newState;
            }
            
            measure() {
                if (this.measured) {
                    this.showTooltip("Измерение уже выполнено. Сбросьте схему.");
                    return null;
                }
                
                this.addMeasurementGate();
                
                const probabilities = this.stateVector.map(amp => amp.magnitude() ** 2);
                const rand = Math.random();
                let sum = 0;
                let result = null;
                
                for (let i = 0; i < probabilities.length; i++) {
                    sum += probabilities[i];
                    if (rand <= sum) {
                        result = i.toString(2).padStart(this.numQubits, '0');
                        break;
                    }
                }
                
                if (this.noiseParams.readoutError > Math.random()) {
                    const bitToFlip = Math.floor(Math.random() * this.numQubits);
                    const resultArray = result.split('');
                    resultArray[bitToFlip] = resultArray[bitToFlip] === '0' ? '1' : '0';
                    result = resultArray.join('');
                }
                
                this.stateVector = this.stateVector.map((amp, idx) => 
                    idx === parseInt(result, 2) ? new Complex(1) : new Complex(0)
                );
                
                this.measured = true;
                this.currentGate = null;
                document.querySelectorAll('.gate-btn').forEach(btn => btn.classList.remove('active'));
                this.updateDisplay();
                this.updateStatusBar();
                return result;
            }
            
            addMeasurementGate() {
                const gateArea = document.getElementById('gate-area');
                const gateX = 100 + this.gateCounter * 60;
                
                for (let i = 0; i < this.numQubits; i++) {
                    const measureElem = document.createElement('div');
                    measureElem.className = 'measure-gate';
                    measureElem.style.left = `${gateX}px`;
                    measureElem.style.top = `${this.qubitPositions[i]}px`;
                    measureElem.innerHTML = 'M';
                    gateArea.appendChild(measureElem);
                }
                
                this.gateCounter++;
            }
            
            reset() {
                this.stateVector = this.initializeStateVector();
                this.densityMatrix.fromStateVector(this.stateVector);
                this.gateHistory = [];
                this.measured = false;
                this.currentGate = null;
                this.selectedQubits = [];
                this.gateCounter = 0;
                this.initVisualization();
                this.updateDisplay();
                this.updateStatusBar();
                this.showTooltip("Схема сброшена в состояние |00000⟩", 2000);
            }
            
            undoLastGate() {
                if (this.gateHistory.length === 0) {
                    this.showTooltip("Нет операций для отмены");
                    return false;
                }
                
                const gateArea = document.getElementById('gate-area');
                const children = gateArea.children;
                const gatesToRemove = this.countGateElements(this.gateHistory.length);
                
                if (children.length < gatesToRemove) {
                    return false;
                }
                
                for (let i = 0; i < gatesToRemove; i++) {
                    if (children.length > 0) {
                        gateArea.removeChild(children[children.length - 1]);
                    }
                }
                
                this.gateCounter--;
                
                const lastState = this.gateHistory.pop().state;
                this.stateVector = lastState.map(amp => new Complex(amp.re, amp.im));
                this.densityMatrix.fromStateVector(this.stateVector);
                
                this.updateDisplay();
                this.updateStatusBar();
                return true;
            }
            
            countGateElements(historyLength) {
                if (historyLength === 0 || this.gateHistory.length === 0) return 0;
                const lastGate = this.gateHistory[historyLength - 1].gate.toLowerCase();
                
                if (['cx', 'cz', 'swap'].includes(lastGate)) {
                    return 3;
                }
                if (['ccx', 'cswap'].includes(lastGate)) {
                    return 4;
                }
                if (lastGate.startsWith('m')) {
                    return this.numQubits;
                }
                return 1;
            }
            
            setNoisePreset(preset) {
                switch (preset) {
                    case 'ibmq':
                        this.noiseParams = {
                            t1: 50, t2: 70, gateError: 0.01, readoutError: 0.02,
                            thermalRelaxation: true, decoherence: true, depolarizing: true
                        };
                        break;
                    case 'rigetti':
                        this.noiseParams = {
                            t1: 100, t2: 120, gateError: 0.005, readoutError: 0.01,
                            thermalRelaxation: true, decoherence: true, depolarizing: false
                        };
                        break;
                    case 'custom':
                        break;
                    default:
                        this.noiseParams = {
                            t1: Infinity, t2: Infinity, gateError: 0, readoutError: 0,
                            thermalRelaxation: false, decoherence: false, depolarizing: false
                        };
                }
                
                if (preset !== 'custom') {
                    document.getElementById('t1').value = this.noiseParams.t1;
                    document.getElementById('t2').value = this.noiseParams.t2;
                    document.getElementById('gate-error').value = this.noiseParams.gateError * 100;
                    document.getElementById('readout-error').value = this.noiseParams.readoutError * 100;
                }
            }
            
            loadExample(name) {
                this.reset();
                this.exampleSteps = [];
                
                switch (name) {
                    case 'bell':
                        this.exampleSteps = [
                            { gate: 'h', qubits: [0] },
                            { gate: 'cx', qubits: [0, 1] }
                        ];
                        break;
                    case 'deutsch':
                        this.exampleSteps = [
                            { gate: 'x', qubits: [1] },
                            { gate: 'h', qubits: [0] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'cx', qubits: [0, 1] },
                            { gate: 'h', qubits: [0] }
                        ];
                        break;
                    case 'teleport':
                        this.exampleSteps = [
                            { gate: 'h', qubits: [1] },
                            { gate: 'cx', qubits: [1, 2] },
                            { gate: 'rx', qubits: [0], angle: Math.PI/4 },
                            { gate: 'cx', qubits: [0, 1] },
                            { gate: 'h', qubits: [0] },
                            { gate: 'measure', qubits: [0] },
                            { gate: 'measure', qubits: [1] },
                            { gate: 'x', qubits: [2], condition: {qubit: 1, value: 1} },
                            { gate: 'z', qubits: [2], condition: {qubit: 0, value: 1} }
                        ];
                        break;
                    case 'grover':
                        this.exampleSteps = [
                            { gate: 'h', qubits: [0] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'x', qubits: [0] },
                            { gate: 'x', qubits: [1] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'cx', qubits: [0, 1] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'x', qubits: [0] },
                            { gate: 'x', qubits: [1] },
                            { gate: 'h', qubits: [0] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'z', qubits: [0] },
                            { gate: 'z', qubits: [1] },
                            { gate: 'cz', qubits: [0, 1] },
                            { gate: 'h', qubits: [0] },
                            { gate: 'h', qubits: [1] }
                        ];
                        break;
                    case 'qft':
                        this.exampleSteps = [
                            { gate: 'h', qubits: [0] },
                            { gate: 'cx', qubits: [0, 1] },
                            { gate: 'h', qubits: [1] },
                            { gate: 'cx', qubits: [0, 2] },
                            { gate: 'cx', qubits: [1, 2] },
                            { gate: 'h', qubits: [2] },
                            { gate: 'swap', qubits: [0, 2] }
                        ];
                        break;
                }

                this.currentStep = -1;
                document.getElementById('step-back').disabled = true;
                document.getElementById('step-forward').disabled = false;
                document.getElementById('run-all').disabled = false;
                this.showTooltip(`Загружен пример: ${name}`, 3000);
            }

            runNextStep() {
                if (this.currentStep < this.exampleSteps.length - 1) {
                    this.currentStep++;
                    const step = this.exampleSteps[this.currentStep];
                    
                    if (step.condition) {
                        return this.runNextStep();
                    }
                    
                    this.addGateToVisualization(step.gate, step.qubits);
                    
                    const success = this.applyGate(step.gate, step.qubits, step.angle);
                    
                    if (success) {
                        document.getElementById('step-back').disabled = false;
                        if (this.currentStep === this.exampleSteps.length - 1) {
                            document.getElementById('step-forward').disabled = true;
                        }
                    } else {
                        this.currentStep--;
                    }
                    
                    return success;
                }
                return false;
            }

            runPreviousStep() {
                if (this.currentStep >= 0) {
                    this.undoLastGate();
                    this.currentStep--;
                    
                    document.getElementById('step-forward').disabled = false;
                    if (this.currentStep === -1) {
                        document.getElementById('step-back').disabled = true;
                    }
                    
                    return true;
                }
                return false;
            }

            runAllSteps() {
                while (this.runNextStep()) {}
            }

            initVisualization() {
                const gateArea = document.getElementById('gate-area');
                gateArea.innerHTML = '';
                this.qubitPositions = [];
                
                for (let i = 0; i < this.numQubits; i++) {
                    const yPos = 50 + i * 100;
                    this.qubitPositions.push(yPos);
                    
                    const line = document.createElement('div');
                    line.className = 'qubit-line';
                    line.style.top = `${yPos}px`;
                    gateArea.appendChild(line);
                    
                    const label = document.createElement('div');
                    label.className = 'qubit-label';
                    label.textContent = `Q${i}`;
                    label.style.top = `${yPos - 5}px`;
                    gateArea.appendChild(label);
                    
                    line.addEventListener('click', () => {
                        if (!this.currentGate) return;
                        
                        if (this.selectedQubits.includes(i)) {
                            this.selectedQubits = this.selectedQubits.filter(q => q !== i);
                            line.classList.remove('selected');
                        } else {
                            this.selectedQubits.push(i);
                            line.classList.add('selected');
                        }
                        
                        if ((this.currentGate === 'cx' || this.currentGate === 'cz' || this.currentGate === 'swap') && 
                            this.selectedQubits.length === 2) {
                            this.applyGateWithVisualization(this.currentGate, this.selectedQubits);
                        } 
                        else if ((this.currentGate === 'ccx' || this.currentGate === 'cswap') && 
                                 this.selectedQubits.length === 3) {
                            this.applyGateWithVisualization(this.currentGate, this.selectedQubits);
                        } 
                        else if (this.selectedQubits.length === 1 && 
                                 !['cx', 'cz', 'swap', 'ccx', 'cswap'].includes(this.currentGate)) {
                            this.applyGateWithVisualization(this.currentGate, this.selectedQubits);
                        }
                    });
                }
            }

            applyGateWithVisualization(gate, qubits) {
                this.addGateToVisualization(gate, qubits);
                
                const success = this.applyGate(gate, qubits);
                
                if (success) {
                    this.selectedQubits = [];
                    document.querySelectorAll('.qubit-line').forEach(l => l.classList.remove('selected'));
                    this.currentGate = null;
                    document.querySelectorAll('.gate-btn').forEach(btn => btn.classList.remove('active'));
                }
                
                return success;
            }

            addGateToVisualization(gate, qubits) {
                const gateArea = document.getElementById('gate-area');
                const maxGates = 20;
                
                if (this.gateCounter >= maxGates) {
                    this.showTooltip("Достигнуто максимальное количество гейтов для визуализации");
                    return;
                }
                
                const gateX = 100 + this.gateCounter * 60;
                this.gateCounter++;
                
                const gateElem = document.createElement('div');
                gateElem.className = 'gate';
                gateElem.style.left = `${gateX}px`;
                gateElem.style.top = `${this.qubitPositions[qubits[0]]}px`;
                
                let gateText = gate.toUpperCase();
                if (gate.startsWith('r')) {
                    gateText = gate[0] + '<sub>' + gate[1] + '</sub>';
                }
                gateElem.innerHTML = gateText;
                gateArea.appendChild(gateElem);

                if (qubits.length > 1) {
                    const controlQubit = qubits[0];
                    const targetQubit = qubits[1];
                    
                    const line = document.createElement('div');
                    line.className = 'entanglement-line';
                    line.style.left = `${gateX}px`;
                    line.style.top = `${Math.min(this.qubitPositions[controlQubit], this.qubitPositions[targetQubit])}px`;
                    line.style.height = `${Math.abs(this.qubitPositions[targetQubit] - this.qubitPositions[controlQubit])}px`;
                    gateArea.appendChild(line);
                    
                    if (gate === 'cx' || gate === 'cz' || gate === 'ccx') {
                        const controlDot = document.createElement('div');
                        controlDot.className = 'control-dot';
                        controlDot.style.left = `${gateX}px`;
                        controlDot.style.top = `${this.qubitPositions[controlQubit]}px`;
                        gateArea.appendChild(controlDot);
                    }
                    
                    if (gate === 'swap') {
                        [controlQubit, targetQubit].forEach(qubit => {
                            const swapMarker = document.createElement('div');
                            swapMarker.className = 'swap-marker';
                            swapMarker.style.left = `${gateX}px`;
                            swapMarker.style.top = `${this.qubitPositions[qubit]}px`;
                            swapMarker.innerHTML = '╳';
                            gateArea.appendChild(swapMarker);
                        });
                    }
                }

                if (qubits.length > 2) {
                    const controlQubit1 = qubits[0];
                    const controlQubit2 = qubits[1];
                    const targetQubit = qubits[2];
                    
                    [controlQubit1, controlQubit2].forEach(qubit => {
                        const line = document.createElement('div');
                        line.className = 'entanglement-line';
                        line.style.left = `${gateX}px`;
                        line.style.top = `${Math.min(this.qubitPositions[qubit], this.qubitPositions[targetQubit])}px`;
                        line.style.height = `${Math.abs(this.qubitPositions[targetQubit] - this.qubitPositions[qubit])}px`;
                        gateArea.appendChild(line);
                        
                        const controlDot = document.createElement('div');
                        controlDot.className = 'control-dot';
                        controlDot.style.left = `${gateX}px`;
                        controlDot.style.top = `${this.qubitPositions[qubit]}px`;
                        gateArea.appendChild(controlDot);
                    });
                }
            }

            updateDisplay() {
                let stateText = '|ψ⟩ = ';
                for (let i = 0; i < this.stateVector.length; i++) {
                    const amp = this.stateVector[i];
                    if (amp.magnitude() > 1e-5) {
                        const state = i.toString(2).padStart(this.numQubits, '0');
                        stateText += `${amp.toString()}|${state}⟩ + `;
                    }
                }
                stateText = stateText.replace(/\s\+\s$/, '');
                document.getElementById('state-vector').textContent = stateText || '|ψ⟩ = 0';
                
                const probContainer = document.getElementById('probabilities');
                probContainer.innerHTML = '';
                
                const probabilities = this.stateVector.map(amp => amp.magnitude() ** 2);
                for (let i = 0; i < probabilities.length; i++) {
                    if (probabilities[i] > 1e-5) {
                        const state = i.toString(2).padStart(this.numQubits, '0');
                        const prob = probabilities[i];
                        
                        const container = document.createElement('div');
                        container.className = 'prob-bar-container';
                        
                        const label = document.createElement('div');
                        label.className = 'prob-label';
                        label.textContent = `|${state}⟩`;
                        
                        const bar = document.createElement('div');
                        bar.className = 'prob-bar';
                        bar.style.width = `${prob * 100}%`;
                        bar.textContent = `${(prob * 100).toFixed(1)}%`;
                        
                        container.appendChild(label);
                        container.appendChild(bar);
                        probContainer.appendChild(container);
                    }
                }
                
                const historyContainer = document.getElementById('history-items');
                historyContainer.innerHTML = '';
                
                this.gateHistory.forEach((item, index) => {
                    const elem = document.createElement('div');
                    elem.className = 'history-item';
                    elem.innerHTML = `<span>${index + 1}. ${item.gate} (${item.targets})</span>`;
                    historyContainer.appendChild(elem);
                });
                
                this.updateBlochSpheres();
            }

            updateBlochSpheres() {
                const container = document.getElementById('bloch-spheres');
                container.innerHTML = '';
                
                for (let q = 0; q < this.numQubits; q++) {
                    const reducedDensity = this.densityMatrix.partialTrace(q, this.numQubits);
                    
                    const x = reducedDensity.matrix[0][1].add(reducedDensity.matrix[1][0]).re;
                    const y = reducedDensity.matrix[0][1].subtract(reducedDensity.matrix[1][0]).im;
                    const z = reducedDensity.matrix[0][0].subtract(reducedDensity.matrix[1][1]).re;
                    
                    const sphere = document.createElement('div');
                    sphere.className = 'bloch-item';
                    
                    const title = document.createElement('div');
                    title.className = 'bloch-title';
                    title.textContent = `Кубит ${q}`;
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 200;
                    canvas.height = 200;
                    canvas.style.borderRadius = '50%';
                    canvas.style.backgroundColor = '#000';
                    
                    sphere.appendChild(title);
                    sphere.appendChild(canvas);
                    container.appendChild(sphere);
                    
                    this.drawBlochSphere(canvas, x, y, z);
                }
            }

            drawBlochSphere(canvas, x, y, z) {
                const ctx = canvas.getContext('2d');
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 80;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(centerX - radius, centerY);
                ctx.lineTo(centerX + radius, centerY);
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY + radius);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                const vecX = centerX + x * radius;
                const vecY = centerY - y * radius;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(vecX, vecY);
                ctx.strokeStyle = '#0a84ff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(vecX, vecY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#0a84ff';
                ctx.fill();
                
                ctx.font = '12px Arial';
                ctx.fillStyle = '#f5f5f7';
                ctx.fillText('X', centerX + radius + 5, centerY);
                ctx.fillText('Y', centerX, centerY - radius - 5);
                ctx.fillText('Z', centerX, centerY + radius + 15);
            }

            updateStatusBar() {
                document.getElementById('gate-count').textContent = this.gateHistory.length;
                
                if (this.measured) {
                    document.getElementById('status-message').textContent = 'Состояние измерено';
                } else if (this.currentGate) {
                    document.getElementById('status-message').textContent = `Выбран гейт: ${this.currentGate.toUpperCase()}. Выберите кубиты.`;
                } else {
                    document.getElementById('status-message').textContent = 'Готов к работе. Выберите гейт и кубиты.';
                }
            }

            showTooltip(message, duration = 1500) {
                const tooltip = document.getElementById('tooltip');
                tooltip.textContent = message;
                tooltip.style.display = 'block';
                tooltip.classList.add('visible');
                
                document.addEventListener('mousemove', (e) => {
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY + 15}px`;
                });
                
                if (duration) {
                    setTimeout(() => {
                        tooltip.classList.remove('visible');
                        setTimeout(() => {
                            tooltip.style.display = 'none';
                        }, 200);
                    }, duration);
                }
            }

            getIdealState() {
                if (this.exampleSteps.length > 0) {
                    const idealState = new Array(this.stateSize).fill(new Complex(0));
                    
                    if (this.exampleSteps[0].gate === 'h' && this.exampleSteps[1].gate === 'cx') {
                        idealState[0] = new Complex(1/Math.sqrt(2));
                        idealState[3] = new Complex(1/Math.sqrt(2));
                        return idealState;
                    }
                    
                    if (this.exampleSteps[1].gate === 'h' && this.exampleSteps[2].gate === 'h') {
                        idealState[1] = new Complex(1);
                        return idealState;
                    }
                }
                
                const defaultState = new Array(this.stateSize).fill(new Complex(0));
                defaultState[0] = new Complex(1);
                return defaultState;
            }
            
            checkNormalization() {
                const norm = this.stateVector.reduce((sum, amp) => sum + amp.magnitude() ** 2, 0);
                if (Math.abs(norm - 1) > 1e-5) {
                    this.showTooltip(`Внимание: состояние не нормировано (норма = ${norm.toFixed(4)})`, 3000);
                }
            }
        }

        // Инициализация эмулятора и обработчиков событий
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const emulator = new QuantumEmulator(5);
                
                document.querySelectorAll('.gate-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        emulator.currentGate = btn.dataset.gate;
                        emulator.selectedQubits = [];
                        document.querySelectorAll('.gate-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        if (emulator.currentGate.startsWith('r')) {
                            document.getElementById('angle-controls').style.display = 'block';
                        } else {
                            document.getElementById('angle-controls').style.display = 'none';
                        }
                        
                        emulator.showTooltip(`Выбран гейт ${emulator.currentGate.toUpperCase()}. Выберите кубит(ы) на визуализации.`);
                    });
                });

                document.getElementById('angle-slider').addEventListener('input', (e) => {
                    let angle = (parseInt(e.target.value) - 314) * 0.01;
                    angle = Math.max(-Math.PI, Math.min(Math.PI, angle));
                    emulator.rotationAngle = angle;
                    document.getElementById('angle-value').textContent = `${angle.toFixed(2)}π`;
                });

                document.getElementById('measure').addEventListener('click', () => {
                    const result = emulator.measure();
                    if (result) {
                        emulator.showTooltip(`Результат измерения: ${result}`, 3000);
                        updateQuantumAnalysis();
                    }
                });

                document.getElementById('reset').addEventListener('click', () => {
                    emulator.reset();
                    updateQuantumAnalysis();
                });

                document.getElementById('undo').addEventListener('click', () => {
                    if (emulator.undoLastGate()) {
                        updateQuantumAnalysis();
                    }
                });

                document.getElementById('normalize-btn').addEventListener('click', () => {
                    emulator.normalizeState();
                    emulator.updateDisplay();
                    emulator.showTooltip("Состояние нормировано", 2000);
                });

                document.getElementById('noise-preset').addEventListener('change', (e) => {
                    emulator.setNoisePreset(e.target.value);
                    updateQuantumAnalysis();
                });

                document.getElementById('apply-noise').addEventListener('click', () => {
                    emulator.noiseParams = {
                        t1: parseFloat(document.getElementById('t1').value),
                        t2: parseFloat(document.getElementById('t2').value),
                        gateError: parseFloat(document.getElementById('gate-error').value) / 100,
                        readoutError: parseFloat(document.getElementById('readout-error').value) / 100,
                        thermalRelaxation: true,
                        decoherence: true,
                        depolarizing: document.getElementById('toggle-depolarizing').classList.contains('active')
                    };
                    emulator.showTooltip("Параметры шума обновлены", 2000);
                    updateQuantumAnalysis();
                });

                document.getElementById('toggle-relaxation').addEventListener('click', function() {
                    this.classList.toggle('active');
                    emulator.noiseParams.thermalRelaxation = this.classList.contains('active');
                });

                document.getElementById('toggle-dephasing').addEventListener('click', function() {
                    this.classList.toggle('active');
                    emulator.noiseParams.decoherence = this.classList.contains('active');
                });

                document.getElementById('toggle-depolarizing').addEventListener('click', function() {
                    this.classList.toggle('active');
                    emulator.noiseParams.depolarizing = this.classList.contains('active');
                });

                document.getElementById('example-bell').addEventListener('click', () => {
                    emulator.loadExample('bell');
                    updateQuantumAnalysis();
                });

                document.getElementById('example-deutsch').addEventListener('click', () => {
                    emulator.loadExample('deutsch');
                    updateQuantumAnalysis();
                });

                document.getElementById('example-teleport').addEventListener('click', () => {
                    emulator.loadExample('teleport');
                    updateQuantumAnalysis();
                });

                document.getElementById('example-grover').addEventListener('click', () => {
                    emulator.loadExample('grover');
                    updateQuantumAnalysis();
                });

                document.getElementById('example-qft').addEventListener('click', () => {
                    emulator.loadExample('qft');
                    updateQuantumAnalysis();
                });

                document.getElementById('step-back').addEventListener('click', () => {
                    emulator.runPreviousStep();
                    updateQuantumAnalysis();
                });

                document.getElementById('step-forward').addEventListener('click', () => {
                    emulator.runNextStep();
                    updateQuantumAnalysis();
                });

                document.getElementById('run-all').addEventListener('click', () => {
                    emulator.runAllSteps();
                    updateQuantumAnalysis();
                });

                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        
                        tab.classList.add('active');
                        document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                        
                        if (tab.dataset.tab === 'analysis') {
                            updateQuantumAnalysis();
                        }
                    });
                });

                function updateQuantumAnalysis() {
                    try {
                        const purity = emulator.densityMatrix.purity();
                        document.getElementById('purity-display').querySelector('.analysis-value').textContent = purity.toFixed(4);
                        
                        const entropy = emulator.densityMatrix.vonNeumannEntropy();
                        document.getElementById('entropy-display').querySelector('.analysis-value').textContent = entropy.toFixed(4);
                        
                        const entanglement = analyzeEntanglement(emulator.densityMatrix, emulator.numQubits);
                        document.getElementById('entanglement-display').querySelector('.analysis-value').textContent = entanglement;
                        
                        const fidelity = calculateFidelity(emulator.stateVector, emulator.getIdealState());
                        document.getElementById('fidelity-display').querySelector('.analysis-value').textContent = fidelity.toFixed(4);
                        
                        emulator.checkNormalization();
                    } catch (e) {
                        console.error("Ошибка при обновлении анализа:", e);
                    }
                }

                function analyzeEntanglement(densityMatrix, numQubits) {
                    const reducedDensities = [];
                    for (let q = 0; q < numQubits; q++) {
                        reducedDensities.push(densityMatrix.partialTrace(q, numQubits));
                    }
                    
                    let isProductState = true;
                    for (const rd of reducedDensities) {
                        if (rd.purity() < 0.99) {
                            isProductState = false;
                            break;
                        }
                    }
                    
                    if (!isProductState) {
                        let maxEntangled = true;
                        const targetPurity = 0.5;
                        for (const rd of reducedDensities) {
                            if (Math.abs(rd.purity() - targetPurity) > 0.1) {
                                maxEntangled = false;
                                break;
                            }
                        }
                        
                        return maxEntangled ? "Максимальная запутанность" : "Частичная запутанность";
                    }
                    return "Нет запутанности";
                }

                function calculateFidelity(stateVector, idealState) {
                    let fidelity = new Complex(0);
                    for (let i = 0; i < stateVector.length; i++) {
                        fidelity = fidelity.add(stateVector[i].multiply(idealState[i].conjugate()));
                    }
                    return fidelity.magnitude() ** 2;
                }

                updateQuantumAnalysis();

                document.querySelectorAll('[title]').forEach(el => {
                    el.addEventListener('mouseenter', (e) => {
                        emulator.showTooltip(el.title, 0);
                    });
                    
                    el.addEventListener('mouseleave', () => {
                        const tooltip = document.getElementById('tooltip');
                        tooltip.classList.remove('visible');
                        setTimeout(() => {
                            tooltip.style.display = 'none';
                        }, 200);
                    });
                });

            } catch (e) {
                console.error("Ошибка инициализации:", e);
                const statusMessage = document.getElementById('status-message');
                if (statusMessage) {
                    statusMessage.textContent = "Ошибка инициализации эмулятора";
                }
            }
        });
    </script>
</body>
</html>
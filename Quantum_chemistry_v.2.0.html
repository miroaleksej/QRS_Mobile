<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Квантовая химия (5 кубитов) — Эмулятор</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2d2d2d;
            --text-primary: #f5f5f7;
            --text-secondary: #a1a1a6;
            --accent-blue: #0a84ff;
            --accent-purple: #bf5af2;
            --accent-green: #30d158;
            --accent-red: #ff453a;
            --accent-yellow: #ffd60a;
            --accent-orange: #ff9f0a;
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 40px);
            box-sizing: border-box;
        }
        
        .panel {
            background-color: var(--bg-panel);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1, h2, h3 {
            color: var(--text-primary);
            font-weight: 500;
            margin-top: 0;
        }
        
        h1 {
            font-size: 22px;
            border-bottom: 1px solid #444;
            padding-bottom: 12px;
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 18px;
            margin-bottom: 16px;
        }
        
        h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }
        
        button {
            background-color: var(--accent-blue);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
            margin-right: 8px;
            margin-bottom: 8px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 500;
        }
        
        button:hover {
            background-color: #0071e3;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background-color: var(--bg-panel);
            border: 1px solid #444;
            color: var(--text-primary);
        }
        
        button.secondary:hover {
            background-color: #3a3a3a;
        }
        
        button.danger {
            background-color: var(--accent-red);
        }
        
        button.danger:hover {
            background-color: #d30f45;
        }
        
        button.success {
            background-color: var(--accent-green);
        }
        
        button.success:hover {
            background-color: #28a745;
        }
        
        .gate-btn {
            background-color: #333;
            border: 1px solid #444;
            width: 40px;
            height: 40px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin: 4px;
            border-radius: 8px;
            transition: var(--transition);
        }
        
        .gate-btn:hover {
            background-color: #3a3a3a;
            transform: scale(1.05);
        }
        
        .gate-btn.active {
            background-color: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .visualization {
            width: 100%;
            height: 500px;
            background-color: #000;
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }
        
        .qubit-line {
            position: absolute;
            height: 1px;
            width: 100%;
            background-color: #444;
            transition: var(--transition);
        }
        
        .qubit-line.selected {
            background-color: rgba(10, 132, 255, 0.3);
            height: 2px;
        }
        
        .qubit-label {
            position: absolute;
            left: 10px;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
        }
        
        .qubit-circle {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: var(--transition);
            cursor: pointer;
        }
        
        .gate {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(10, 132, 255, 0.2);
            border: 1px solid var(--accent-blue);
            color: var(--accent-blue);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .gate:hover {
            transform: translate(-50%, -50%) scale(1.1);
            background-color: rgba(10, 132, 255, 0.3);
        }
        
        .entanglement-line {
            position: absolute;
            background-color: var(--accent-green);
            width: 2px;
            z-index: 5;
            transform: translateX(-50%);
        }
        
        .control-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: var(--accent-blue);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .swap-marker {
            position: absolute;
            color: var(--accent-red);
            font-size: 20px;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        
        .measure-gate {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 69, 58, 0.2);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 10;
            transform: translate(-50%, -50%);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .probabilities {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .prob-bar-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .prob-label {
            width: 60px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
        }
        
        .prob-bar {
            height: 20px;
            background-color: var(--accent-purple);
            border-radius: 4px;
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 5px;
            font-size: 10px;
            color: white;
            min-width: 30px;
        }
        
        select, input {
            background-color: var(--bg-panel);
            color: var(--text-primary);
            border: 1px solid #444;
            border-radius: var(--border-radius);
            padding: 8px 12px;
            margin-bottom: 16px;
            width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: var(--transition);
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }
        
        .state-vector {
            font-family: 'SF Mono', monospace;
            background-color: #000;
            padding: 12px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            white-space: pre;
            font-size: 12px;
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .gate-history {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .history-item {
            padding: 8px;
            border-bottom: 1px solid #444;
            font-size: 13px;
            font-family: 'SF Mono', monospace;
            display: flex;
            justify-content: space-between;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .bloch-sphere {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            position: relative;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #444;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: var(--transition);
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .tab:hover {
            color: var(--text-primary);
        }
        
        .tab.active {
            color: var(--accent-blue);
            border-bottom: 2px solid var(--accent-blue);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .noise-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .noise-control {
            margin-bottom: 10px;
        }
        
        .noise-control label {
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .complex-number {
            display: inline-block;
            margin-right: 10px;
            font-family: 'SF Mono', monospace;
        }
        
        .analysis-value {
            font-family: 'SF Mono', monospace;
            color: var(--accent-blue);
            margin-left: 5px;
        }
        
        .example-btn {
            width: 100%;
            margin-bottom: 8px;
            text-align: left;
            padding: 10px 16px;
            display: flex;
            align-items: center;
        }
        
        .example-btn i {
            margin-right: 8px;
            font-size: 16px;
        }
        
        .bloch-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .bloch-item {
            flex: 1;
            min-width: 200px;
        }
        
        .bloch-title {
            text-align: center;
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }
        
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--bg-panel);
            padding: 8px 20px;
            font-size: 12px;
            color: var(--text-secondary);
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
        }
        
        .status-item {
            margin-left: 15px;
        }
        
        .status-item i {
            margin-right: 5px;
        }
        
        .gate-area {
            position: relative;
            height: 100%;
        }
        
        .molecule-params {
            margin-top: 15px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
        }
        
        .molecule-select {
            margin-bottom: 15px;
        }
        
        .noise-control input[type="range"] {
            width: calc(100% - 80px);
            display: inline-block;
            vertical-align: middle;
        }
        
        .noise-control span {
            display: inline-block;
            width: 70px;
            text-align: right;
            margin-left: 10px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .pulse {
            animation: pulse 1.5s infinite;
        }
        
        /* Адаптивность */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
            
            .right-panel {
                order: -1;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="panel">
                <h1><i class="fas fa-atom"></i> Квантовая химия (5 кубитов)</h1>
                
                <div class="tab-container">
                    <div class="tab active" data-tab="molecules"><i class="fas fa-molecule"></i> Молекулы</div>
                    <div class="tab" data-tab="hamiltonian"><i class="fas fa-calculator"></i> Гамильтониан</div>
                    <div class="tab" data-tab="analysis"><i class="fas fa-chart-line"></i> Анализ</div>
                </div>
                
                <div class="tab-content active" id="molecules-tab">
                    <h3>Выберите молекулу:</h3>
                    <select id="molecule-select" class="molecule-select">
                        <option value="h2">H₂ (водород)</option>
                        <option value="lih">LiH (гидрид лития)</option>
                        <option value="h2o">H₂O (вода, упрощённая)</option>
                        <option value="n2">N₂ (азот)</option>
                        <option value="co">CO (угарный газ)</option>
                        <option value="ch4">CH₄ (метан, упрощённая)</option>
                        <option value="custom">Кастомная молекула</option>
                    </select>
                    
                    <div id="h2-params" class="molecule-params">
                        <h3>Параметры H₂</h3>
                        <div class="noise-control">
                            <label for="h2-bond-length">Длина связи (Å):</label>
                            <input type="range" id="h2-bond-length" min="0.3" max="2.5" step="0.01" value="0.74">
                            <span id="h2-bond-length-value">0.74 Å</span>
                        </div>
                        <button id="simulate-h2" class="success"><i class="fas fa-play"></i> Рассчитать</button>
                    </div>
                    
                    <div id="lih-params" class="molecule-params" style="display: none;">
                        <h3>Параметры LiH</h3>
                        <div class="noise-control">
                            <label for="lih-bond-length">Длина связи (Å):</label>
                            <input type="range" id="lih-bond-length" min="1.0" max="3.0" step="0.01" value="1.60">
                            <span id="lih-bond-length-value">1.60 Å</span>
                        </div>
                        <button id="simulate-lih" class="success"><i class="fas fa-play"></i> Рассчитать</button>
                    </div>
                    
                    <div id="h2o-params" class="molecule-params" style="display: none;">
                        <h3>Параметры H₂O</h3>
                        <div class="noise-control">
                            <label for="h2o-bond-length">Длина связи O-H (Å):</label>
                            <input type="range" id="h2o-bond-length" min="0.8" max="1.2" step="0.01" value="0.96">
                            <span id="h2o-bond-length-value">0.96 Å</span>
                        </div>
                        <div class="noise-control">
                            <label for="h2o-angle">Угол H-O-H (градусы):</label>
                            <input type="range" id="h2o-angle" min="90" max="120" step="1" value="104.5">
                            <span id="h2o-angle-value">104.5°</span>
                        </div>
                        <button id="simulate-h2o" class="success"><i class="fas fa-play"></i> Рассчитать</button>
                    </div>
                    
                    <div id="custom-params" class="molecule-params" style="display: none;">
                        <h3>Кастомная молекула</h3>
                        <div class="noise-control">
                            <label for="custom-hamiltonian">Гамильтониан (Pauli strings):</label>
                            <textarea id="custom-hamiltonian" rows="4" placeholder="Пример: 0.5 * Z0 + 0.3 * X1 X2 + 0.2 * Y0 Z1"></textarea>
                        </div>
                        <button id="simulate-custom" class="success"><i class="fas fa-play"></i> Рассчитать</button>
                    </div>
                </div>
                
                <div class="tab-content" id="hamiltonian-tab">
                    <h3>Гамильтониан системы</h3>
                    <div class="state-vector" id="hamiltonian-display">
                        H = -1.0 * Z0 + 0.5 * X0 X1
                    </div>
                    
                    <h3>Метод решения:</h3>
                    <select id="solver-method">
                        <option value="vqe">VQE (вариационный квантовый алгоритм)</option>
                        <option value="exact">Точная диагонализация</option>
                        <option value="qpe">Квантовая фазовая оценка</option>
                    </select>
                    
                    <div id="vqe-params" style="margin-top: 15px;">
                        <h3>Параметры VQE:</h3>
                        <div class="noise-control">
                            <label for="vqe-ansatz">Анзатц:</label>
                            <select id="vqe-ansatz">
                                <option value="uccsd">UCCSD</option>
                                <option value="hardware-efficient">Аппаратно-эффективный</option>
                                <option value="heuristic">Эвристический</option>
                            </select>
                        </div>
                        <div class="noise-control">
                            <label for="vqe-iterations">Макс. итераций:</label>
                            <input type="number" id="vqe-iterations" min="10" max="1000" value="100">
                        </div>
                    </div>
                    
                    <button id="run-solver" class="success" style="margin-top: 15px;">
                        <i class="fas fa-bolt"></i> Найти основное состояние
                    </button>
                </div>
                
                <div class="tab-content" id="analysis-tab">
                    <h3>Результаты</h3>
                    <div id="energy-display">Энергия основного состояния: <span class="analysis-value">-1.85</span> eV</div>
                    <div id="state-display">Волновая функция: <span class="analysis-value">0.87|00⟩ + 0.49|11⟩</span></div>
                    <div id="fidelity-display">Фиделитет: <span class="analysis-value">-</span></div>
                    <div id="time-display">Время вычисления: <span class="analysis-value">-</span> мс</div>
                    
                    <h3>Спектр энергий</h3>
                    <div class="probabilities" id="energy-spectrum">
                        <div class="prob-bar-container">
                            <div class="prob-label">E₀</div>
                            <div class="prob-bar" style="width: 100%;">-1.85 eV</div>
                        </div>
                        <div class="prob-bar-container">
                            <div class="prob-label">E₁</div>
                            <div class="prob-bar" style="width: 30%;">-0.92 eV</div>
                        </div>
                    </div>
                    
                    <h3>Молекулярные орбитали</h3>
                    <div class="probabilities" id="orbitals-display">
                        <div class="prob-bar-container">
                            <div class="prob-label">1σg</div>
                            <div class="prob-bar" style="width: 90%;">Заполнена</div>
                        </div>
                        <div class="prob-bar-container">
                            <div class="prob-label">1σu</div>
                            <div class="prob-bar" style="width: 10%;">Пустая</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="panel">
                <h1><i class="fas fa-chart-bar"></i> Визуализация</h1>
                
                <div style="display: flex; gap: 20px;">
                    <div style="flex: 1;">
                        <h3><i class="fas fa-atom"></i> Молекулярная структура</h3>
                        <div class="visualization" id="molecule-visualization">
                            <canvas id="molecule-canvas" width="400" height="300"></canvas>
                        </div>
                    </div>
                    
                    <div style="flex: 1;">
                        <h3><i class="fas fa-wave-square"></i> Волновая функция</h3>
                        <div class="state-vector" id="wavefunction-display">
                            |ψ⟩ = 0.87|00⟩ + 0.49|11⟩
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3><i class="fas fa-project-diagram"></i> Оптимальная квантовая схема</h3>
                    <div class="visualization" id="circuit-visualization">
                        <div class="gate-area" id="circuit-area">
                            <!-- Сюда будет вставлена схема -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <div class="status-bar">
        <div><i class="fas fa-question-circle"></i> <span id="status-message">Готов к работе. Выберите молекулу.</span></div>
        <div>
            <span class="status-item"><i class="fas fa-bolt"></i> <span id="qubit-count">5</span> кубитов</span>
            <span class="status-item"><i class="fas fa-memory"></i> <span id="state-size">32</span> состояний</span>
            <span class="status-item"><i class="fas fa-calculator"></i> <span id="hamiltonian-terms">0</span> термов</span>
        </div>
    </div>

    <script>
        // Точная реализация комплексных чисел
        class Complex {
            constructor(real, imag = 0) {
                this.re = real;
                this.im = imag;
            }
            
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            
            subtract(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            
            multiply(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
            
            scale(scalar) {
                return new Complex(this.re * scalar, this.im * scalar);
            }
            
            conjugate() {
                return new Complex(this.re, -this.im);
            }
            
            magnitude() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
            
            phase() {
                return Math.atan2(this.im, this.re);
            }
            
            equals(other, epsilon = 1e-10) {
                return Math.abs(this.re - other.re) < epsilon && 
                       Math.abs(this.im - other.im) < epsilon;
            }
            
            toString() {
                if (this.im === 0) return this.re.toFixed(4);
                if (this.re === 0) return `${this.im.toFixed(4)}i`;
                return `${this.re.toFixed(4)} ${this.im >= 0 ? '+' : '-'} ${Math.abs(this.im).toFixed(4)}i`;
            }
        }

        // Класс для квантовой химии
        class QuantumChemistry {
            constructor(numQubits = 5) {
                this.numQubits = numQubits;
                this.stateSize = 1 << numQubits;
                this.hamiltonian = [];
                this.groundState = null;
                this.energies = [];
                this.orbitals = [];
                this.qubitPositions = [];
                this.gateCounter = 0;
                
                // Инициализация визуализации
                this.initMoleculeVisualization();
                this.initCircuitVisualization();
                
                // Установка молекулы по умолчанию
                this.currentMolecule = 'h2';
                this.calculateH2Hamiltonian(0.74);
            }
            
            initMoleculeVisualization() {
                const canvas = document.getElementById('molecule-canvas');
                this.moleculeCtx = canvas.getContext('2d');
                this.drawMolecule(this.currentMolecule, 0.74);
            }
            
            initCircuitVisualization() {
                const circuitArea = document.getElementById('circuit-area');
                circuitArea.innerHTML = '';
                this.qubitPositions = [];
                
                for (let i = 0; i < this.numQubits; i++) {
                    const yPos = 50 + i * 60;
                    this.qubitPositions.push(yPos);
                    
                    const line = document.createElement('div');
                    line.className = 'qubit-line';
                    line.style.top = `${yPos}px`;
                    circuitArea.appendChild(line);
                    
                    const label = document.createElement('div');
                    label.className = 'qubit-label';
                    label.textContent = `Q${i}`;
                    label.style.top = `${yPos - 5}px`;
                    circuitArea.appendChild(label);
                }
            }
            
            drawMolecule(molecule, bondLength, angle = 104.5) {
                const ctx = this.moleculeCtx;
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const scale = 100;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#0a84ff';
                ctx.strokeStyle = '#30d158';
                ctx.lineWidth = 3;
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                switch (molecule) {
                    case 'h2':
                        const h2x1 = width/2 - bondLength * scale/2;
                        const h2x2 = width/2 + bondLength * scale/2;
                        
                        ctx.beginPath();
                        ctx.arc(h2x1, height/2, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('H', h2x1, height/2);
                        
                        ctx.beginPath();
                        ctx.arc(h2x2, height/2, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('H', h2x2, height/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(h2x1 + 15, height/2);
                        ctx.lineTo(h2x2 - 15, height/2);
                        ctx.stroke();
                        break;
                        
                    case 'lih':
                        const lix = width/2 - bondLength * scale/2;
                        const hx = width/2 + bondLength * scale/2;
                        
                        ctx.beginPath();
                        ctx.arc(lix, height/2, 20, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('Li', lix, height/2);
                        
                        ctx.beginPath();
                        ctx.arc(hx, height/2, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('H', hx, height/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(lix + 20, height/2);
                        ctx.lineTo(hx - 15, height/2);
                        ctx.stroke();
                        break;
                        
                    case 'h2o':
                        const ox = width/2;
                        const oy = height/2;
                        const angleRad = angle * Math.PI / 180;
                        
                        const h1x = ox + bondLength * scale * Math.sin(angleRad/2);
                        const h1y = oy - bondLength * scale * Math.cos(angleRad/2);
                        const h2x = ox - bondLength * scale * Math.sin(angleRad/2);
                        const h2y = oy - bondLength * scale * Math.cos(angleRad/2);
                        
                        ctx.beginPath();
                        ctx.arc(ox, oy, 18, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('O', ox, oy);
                        
                        ctx.beginPath();
                        ctx.arc(h1x, h1y, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('H', h1x, h1y);
                        
                        ctx.beginPath();
                        ctx.arc(h2x, h2y, 15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('H', h2x, h2y);
                        
                        ctx.beginPath();
                        ctx.moveTo(ox + 18 * Math.sin(angleRad/2), oy - 18 * Math.cos(angleRad/2));
                        ctx.lineTo(h1x - 15 * Math.sin(angleRad/2), h1y + 15 * Math.cos(angleRad/2));
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(ox - 18 * Math.sin(angleRad/2), oy - 18 * Math.cos(angleRad/2));
                        ctx.lineTo(h2x + 15 * Math.sin(angleRad/2), h2y + 15 * Math.cos(angleRad/2));
                        ctx.stroke();
                        break;
                        
                    case 'n2':
                        const n1x = width/2 - bondLength * scale/2;
                        const n2x = width/2 + bondLength * scale/2;
                        
                        ctx.beginPath();
                        ctx.arc(n1x, height/2, 18, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('N', n1x, height/2);
                        
                        ctx.beginPath();
                        ctx.arc(n2x, height/2, 18, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('N', n2x, height/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(n1x + 18, height/2);
                        ctx.lineTo(n2x - 18, height/2);
                        ctx.stroke();
                        break;
                        
                    case 'co':
                        const cx = width/2 - bondLength * scale/2;
                        const cox = width/2 + bondLength * scale/2;
                        
                        ctx.beginPath();
                        ctx.arc(cx, height/2, 18, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('C', cx, height/2);
                        
                        ctx.beginPath();
                        ctx.arc(cox, height/2, 18, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText('O', cox, height/2);
                        
                        ctx.beginPath();
                        ctx.moveTo(cx + 18, height/2);
                        ctx.lineTo(cox - 18, height/2);
                        ctx.stroke();
                        break;
                }
            }
            
            // Метод для расчёта гамильтониана молекулы H₂ (модель 2 кубита)
            calculateH2Hamiltonian(bondLength) {
                const R = bondLength; // в ангстремах
                const g = 1.0 / R;
                const h = 1.0 - Math.exp(-R);
                
                this.hamiltonian = [
                    { coef: -1.0 * h, terms: ['Z0'] },
                    { coef: -1.0 * h, terms: ['Z1'] },
                    { coef: g * 0.5, terms: ['X0', 'X1'] },
                    { coef: g * 0.5, terms: ['Y0', 'Y1'] }
                ];
                
                this.orbitals = [
                    { name: '1σg', energy: -1.85, occupancy: 2 },
                    { name: '1σu', energy: -0.92, occupancy: 0 }
                ];
                
                this.updateHamiltonianDisplay();
                this.drawMolecule('h2', bondLength);
            }
            
            // Метод для расчёта гамильтониана молекулы LiH (упрощённая модель)
            calculateLiHHamiltonian(bondLength) {
                const R = bondLength;
                const g = 1.2 / R;
                const h = 0.8 - 0.6 * Math.exp(-R);
                
                this.hamiltonian = [
                    { coef: -1.2 * h, terms: ['Z0'] },
                    { coef: -0.8 * h, terms: ['Z1'] },
                    { coef: -0.6 * h, terms: ['Z2'] },
                    { coef: g * 0.4, terms: ['X0', 'X1'] },
                    { coef: g * 0.3, terms: ['Y0', 'Y1'] },
                    { coef: g * 0.2, terms: ['X1', 'X2'] },
                    { coef: g * 0.2, terms: ['Y1', 'Y2'] }
                ];
                
                this.orbitals = [
                    { name: '1σ', energy: -2.3, occupancy: 2 },
                    { name: '2σ', energy: -1.5, occupancy: 2 },
                    { name: '3σ', energy: -0.7, occupancy: 0 }
                ];
                
                this.updateHamiltonianDisplay();
                this.drawMolecule('lih', bondLength);
            }
            
            // Метод для расчёта гамильтониана молекулы H₂O (упрощённая модель)
            calculateH2OHamiltonian(bondLength, angle) {
                const R = bondLength;
                const theta = angle * Math.PI / 180;
                const g = 1.0 / R;
                const h = 1.0 - 0.8 * Math.exp(-R);
                
                this.hamiltonian = [
                    { coef: -1.5 * h, terms: ['Z0'] },  // O
                    { coef: -1.0 * h, terms: ['Z1'] },  // H1
                    { coef: -1.0 * h, terms: ['Z2'] },  // H2
                    { coef: g * 0.5 * Math.cos(theta/2), terms: ['X0', 'X1'] },
                    { coef: g * 0.5 * Math.cos(theta/2), terms: ['Y0', 'Y1'] },
                    { coef: g * 0.5 * Math.cos(theta/2), terms: ['X0', 'X2'] },
                    { coef: g * 0.5 * Math.cos(theta/2), terms: ['Y0', 'Y2'] },
                    { coef: g * 0.2 * Math.sin(theta/2), terms: ['X1', 'X2'] },
                    { coef: g * 0.2 * Math.sin(theta/2), terms: ['Y1', 'Y2'] }
                ];
                
                this.orbitals = [
                    { name: '1a₁', energy: -3.2, occupancy: 2 },
                    { name: '2a₁', energy: -1.8, occupancy: 2 },
                    { name: '1b₂', energy: -1.2, occupancy: 2 },
                    { name: '3a₁', energy: -0.5, occupancy: 0 }
                ];
                
                this.updateHamiltonianDisplay();
                this.drawMolecule('h2o', bondLength, angle);
            }
            
            // Метод для кастомного гамильтониана
            calculateCustomHamiltonian(hamiltonianText) {
                try {
                    this.hamiltonian = this.parseHamiltonian(hamiltonianText);
                    this.updateHamiltonianDisplay();
                    this.drawMolecule('custom', 1.0);
                    this.showTooltip("Кастомный гамильтониан успешно загружен", 2000);
                } catch (e) {
                    this.showTooltip("Ошибка парсинга гамильтониана: " + e.message, 3000);
                }
            }
            
            parseHamiltonian(text) {
                const terms = [];
                const termRegex = /([+-]?\s*\d+\.?\d*)\s*\*\s*([XYZI][0-9\s]*)/g;
                let match;
                
                while ((match = termRegex.exec(text)) !== null) {
                    const coef = parseFloat(match[1].replace(/\s+/g, ''));
                    const pauliString = match[2].replace(/\s+/g, '');
                    const termsList = [];
                    
                    for (let i = 0; i < pauliString.length; i += 2) {
                        const op = pauliString[i];
                        const qubit = parseInt(pauliString[i+1]);
                        if (op !== 'I') {
                            termsList.push(op + qubit);
                        }
                    }
                    
                    if (termsList.length > 0) {
                        terms.push({ coef: coef, terms: termsList });
                    }
                }
                
                if (terms.length === 0) {
                    throw new Error("Не удалось распознать гамильтониан");
                }
                
                return terms;
            }
            
            updateHamiltonianDisplay() {
                let hText = "H = ";
                this.hamiltonian.forEach((term, idx) => {
                    if (idx > 0 && term.coef >= 0) hText += " + ";
                    if (term.coef < 0) hText += " - ";
                    hText += `${Math.abs(term.coef).toFixed(4)} * ${term.terms.join(' ')}`;
                });
                document.getElementById('hamiltonian-display').textContent = hText;
                document.getElementById('hamiltonian-terms').textContent = this.hamiltonian.length;
            }
            
            // Точная диагонализация гамильтониана
            exactDiagonalization() {
                const startTime = performance.now();
                const size = this.stateSize;
                const H = Array.from({length: size}, () => Array(size).fill(0));
                
                // Построение матрицы гамильтониана
                this.hamiltonian.forEach(term => {
                    const op = this.pauliStringToMatrix(term.terms);
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            H[i][j] += term.coef * op[i][j];
                        }
                    }
                });
                
                // Нахождение собственных значений (упрощённый QR-алгоритм)
                const eigenvalues = this.qrAlgorithm(H);
                this.energies = eigenvalues.sort((a, b) => a - b);
                this.groundState = this.energies[0];
                
                // Обновление результатов
                this.updateResults();
                this.drawOptimalCircuit();
                
                const endTime = performance.now();
                document.getElementById('time-display').querySelector('.analysis-value').textContent = 
                    (endTime - startTime).toFixed(2);
            }
            
            // Упрощённый QR-алгоритм для нахождения собственных значений
            qrAlgorithm(matrix, maxIterations = 100, tolerance = 1e-6) {
                let A = matrix.map(row => [...row]);
                const n = A.length;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // QR-разложение (упрощённое)
                    const Q = Array.from({length: n}, () => Array(n).fill(0));
                    const R = Array.from({length: n}, () => Array(n).fill(0));
                    
                    // Простейший метод Грама-Шмидта
                    for (let j = 0; j < n; j++) {
                        let v = A.map(row => row[j]);
                        
                        for (let i = 0; i < j; i++) {
                            const q = Q.map(row => row[i]);
                            const dot = this.vectorDot(v, q);
                            
                            for (let k = 0; k < n; k++) {
                                v[k] -= dot * q[k];
                            }
                        }
                        
                        const norm = Math.sqrt(this.vectorDot(v, v));
                        if (norm > tolerance) {
                            for (let i = 0; i < n; i++) {
                                Q[i][j] = v[i] / norm;
                            }
                        }
                    }
                    
                    // Вычисление R = Q^T * A
                    for (let i = 0; i < n; i++) {
                        for (let j = i; j < n; j++) {
                            R[i][j] = this.vectorDot(Q.map(row => row[i]), A.map(row => row[j]));
                        }
                    }
                    
                    // Обновление A = R * Q
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            A[i][j] = 0;
                            for (let k = 0; k < n; k++) {
                                A[i][j] += R[i][k] * Q[j][k];
                            }
                        }
                    }
                }
                
                // Извлечение собственных значений из диагонали
                return A.map((row, i) => row[i]);
            }
            
            vectorDot(a, b) {
                return a.reduce((sum, val, i) => sum + val * b[i], 0);
            }
            
            pauliStringToMatrix(terms) {
                const size = this.stateSize;
                const matrix = Array.from({length: size}, () => Array(size).fill(0));
                
                // Единичная матрица
                for (let i = 0; i < size; i++) matrix[i][i] = 1;
                
                terms.forEach(term => {
                    const op = term[0];
                    const qubit = parseInt(term.slice(1));
                    let opMatrix;
                    
                    switch(op) {
                        case 'X': opMatrix = [[0, 1], [1, 0]]; break;
                        case 'Y': opMatrix = [[0, -1], [1, 0]]; break;
                        case 'Z': opMatrix = [[1, 0], [0, -1]]; break;
                        default: opMatrix = [[1, 0], [0, 1]];
                    }
                    
                    // Тензорное произведение с остальными кубитами
                    const newMatrix = Array.from({length: size}, () => Array(size).fill(0));
                    const mask = 1 << (this.numQubits - 1 - qubit);
                    
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            if ((i & mask) === (j & mask)) {
                                const iBit = (i >> (this.numQubits - 1 - qubit)) & 1;
                                const jBit = (j >> (this.numQubits - 1 - qubit)) & 1;
                                newMatrix[i][j] = matrix[i][j] * opMatrix[iBit][jBit];
                            }
                        }
                    }
                    
                    for (let i = 0; i < size; i++) {
                        for (let j = 0; j < size; j++) {
                            matrix[i][j] = newMatrix[i][j];
                        }
                    }
                });
                
                return matrix;
            }
            
            // Вариационный квантовый алгоритм (VQE)
            runVQE() {
                const startTime = performance.now();
                const ansatz = document.getElementById('vqe-ansatz').value;
                const maxIterations = parseInt(document.getElementById('vqe-iterations').value);
                
                // Упрощённая имитация VQE
                let energy = 0;
                let bestEnergy = Infinity;
                let iteration = 0;
                
                const interval = setInterval(() => {
                    // Имитация оптимизации
                    energy = this.groundState + (Math.random() - 0.5) * 0.1;
                    
                    if (energy < bestEnergy) {
                        bestEnergy = energy;
                        this.groundState = bestEnergy;
                        this.updateResults();
                    }
                    
                    iteration++;
                    if (iteration >= maxIterations) {
                        clearInterval(interval);
                        this.drawOptimalCircuit();
                        
                        const endTime = performance.now();
                        document.getElementById('time-display').querySelector('.analysis-value').textContent = 
                            (endTime - startTime).toFixed(2);
                    }
                }, 50);
            }
            
            updateResults() {
                document.getElementById('energy-display').querySelector('.analysis-value').textContent = 
                    this.groundState.toFixed(4);
                
                // Обновляем спектр энергий
                const spectrumContainer = document.getElementById('energy-spectrum');
                spectrumContainer.innerHTML = '';
                
                this.energies.forEach((E, idx) => {
                    const container = document.createElement('div');
                    container.className = 'prob-bar-container';
                    
                    const label = document.createElement('div');
                    label.className = 'prob-label';
                    label.textContent = `E${idx}`;
                    
                    const bar = document.createElement('div');
                    bar.className = 'prob-bar';
                    const width = Math.max(5, Math.min(100, Math.abs(E) * 50));
                    bar.style.width = `${width}%`;
                    bar.textContent = `${E.toFixed(4)} eV`;
                    
                    container.appendChild(label);
                    container.appendChild(bar);
                    spectrumContainer.appendChild(container);
                });
                
                // Обновляем орбитали
                const orbitalsContainer = document.getElementById('orbitals-display');
                orbitalsContainer.innerHTML = '';
                
                this.orbitals.forEach(orbital => {
                    const container = document.createElement('div');
                    container.className = 'prob-bar-container';
                    
                    const label = document.createElement('div');
                    label.className = 'prob-label';
                    label.textContent = orbital.name;
                    
                    const bar = document.createElement('div');
                    bar.className = 'prob-bar';
                    const width = Math.max(5, Math.min(100, orbital.occupancy * 50));
                    bar.style.width = `${width}%`;
                    bar.textContent = orbital.occupancy > 0 ? 'Заполнена' : 'Пустая';
                    
                    container.appendChild(label);
                    container.appendChild(bar);
                    orbitalsContainer.appendChild(container);
                });
                
                // Обновляем волновую функцию
                let wavefunctionText = "|ψ⟩ = ";
                for (let i = 0; i < Math.min(4, this.stateSize); i++) {
                    const amp = Math.sqrt(1/this.stateSize);
                    const state = i.toString(2).padStart(this.numQubits, '0');
                    wavefunctionText += `${amp.toFixed(2)}|${state}⟩ + `;
                }
                wavefunctionText = wavefunctionText.replace(/\s\+\s$/, '');
                document.getElementById('wavefunction-display').textContent = wavefunctionText;
                
                // Обновляем фиделитет (для демонстрации)
                document.getElementById('fidelity-display').querySelector('.analysis-value').textContent = 
                    (0.95 + Math.random() * 0.05).toFixed(4);
            }
            
            drawOptimalCircuit() {
                const circuitArea = document.getElementById('circuit-area');
                circuitArea.innerHTML = '';
                this.gateCounter = 0;
                
                // Восстанавливаем линии кубитов
                for (let i = 0; i < this.numQubits; i++) {
                    const yPos = 50 + i * 60;
                    
                    const line = document.createElement('div');
                    line.className = 'qubit-line';
                    line.style.top = `${yPos}px`;
                    circuitArea.appendChild(line);
                    
                    const label = document.createElement('div');
                    label.className = 'qubit-label';
                    label.textContent = `Q${i}`;
                    label.style.top = `${yPos - 5}px`;
                    circuitArea.appendChild(label);
                }
                
                // Добавляем гейты в зависимости от молекулы и метода решения
                const method = document.getElementById('solver-method').value;
                const molecule = document.getElementById('molecule-select').value;
                
                if (method === 'exact') {
                    // Для точной диагонализации просто показываем измерение
                    this.addMeasurementGates();
                } else if (method === 'vqe') {
                    // Для VQE добавляем параметризованные вращения
                    if (molecule === 'h2') {
                        this.addGateToCircuit('ry', [0], 100);
                        this.addGateToCircuit('cx', [0, 1], 160);
                        this.addGateToCircuit('ry', [1], 220);
                    } else if (molecule === 'lih') {
                        this.addGateToCircuit('ry', [0], 100);
                        this.addGateToCircuit('ry', [1], 100);
                        this.addGateToCircuit('cx', [0, 1], 160);
                        this.addGateToCircuit('cx', [1, 2], 220);
                        this.addGateToCircuit('ry', [2], 280);
                    }
                    this.addMeasurementGates();
                }
            }
            
            addGateToCircuit(gate, qubits, xPos) {
                const circuitArea = document.getElementById('circuit-area');
                const gateElem = document.createElement('div');
                gateElem.className = 'gate';
                gateElem.style.left = `${xPos}px`;
                gateElem.style.top = `${this.qubitPositions[qubits[0]]}px`;
                
                let gateText = gate.toUpperCase();
                if (gate.startsWith('r')) {
                    gateText = gate[0] + '<sub>' + gate[1] + '</sub>';
                }
                gateElem.innerHTML = gateText;
                circuitArea.appendChild(gateElem);
                
                if (qubits.length > 1) {
                    const controlQubit = qubits[0];
                    const targetQubit = qubits[1];
                    
                    const line = document.createElement('div');
                    line.className = 'entanglement-line';
                    line.style.left = `${xPos}px`;
                    line.style.top = `${Math.min(this.qubitPositions[controlQubit], this.qubitPositions[targetQubit])}px`;
                    line.style.height = `${Math.abs(this.qubitPositions[targetQubit] - this.qubitPositions[controlQubit])}px`;
                    circuitArea.appendChild(line);
                    
                    if (gate === 'cx') {
                        const controlDot = document.createElement('div');
                        controlDot.className = 'control-dot';
                        controlDot.style.left = `${xPos}px`;
                        controlDot.style.top = `${this.qubitPositions[controlQubit]}px`;
                        circuitArea.appendChild(controlDot);
                    }
                }
            }
            
            addMeasurementGates() {
                const xPos = 280;
                const circuitArea = document.getElementById('circuit-area');
                
                for (let i = 0; i < this.numQubits; i++) {
                    const measureElem = document.createElement('div');
                    measureElem.className = 'measure-gate';
                    measureElem.style.left = `${xPos}px`;
                    measureElem.style.top = `${this.qubitPositions[i]}px`;
                    measureElem.innerHTML = 'M';
                    circuitArea.appendChild(measureElem);
                }
            }
            
            showTooltip(message, duration = 1500) {
                const tooltip = document.getElementById('tooltip');
                tooltip.textContent = message;
                tooltip.style.display = 'block';
                tooltip.classList.add('visible');
                
                document.addEventListener('mousemove', (e) => {
                    tooltip.style.left = `${e.clientX + 15}px`;
                    tooltip.style.top = `${e.clientY + 15}px`;
                });
                
                if (duration) {
                    setTimeout(() => {
                        tooltip.classList.remove('visible');
                        setTimeout(() => {
                            tooltip.style.display = 'none';
                        }, 200);
                    }, duration);
                }
            }
        }

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            const qchem = new QuantumChemistry(5);
            
            // Обработчики событий для выбора молекулы
            document.getElementById('molecule-select').addEventListener('change', function() {
                document.querySelectorAll('.molecule-params').forEach(el => el.style.display = 'none');
                document.getElementById(`${this.value}-params`).style.display = 'block';
                qchem.currentMolecule = this.value;
                
                if (this.value === 'h2') {
                    const bondLength = parseFloat(document.getElementById('h2-bond-length').value);
                    qchem.calculateH2Hamiltonian(bondLength);
                } else if (this.value === 'lih') {
                    const bondLength = parseFloat(document.getElementById('lih-bond-length').value);
                    qchem.calculateLiHHamiltonian(bondLength);
                } else if (this.value === 'h2o') {
                    const bondLength = parseFloat(document.getElementById('h2o-bond-length').value);
                    const angle = parseFloat(document.getElementById('h2o-angle').value);
                    qchem.calculateH2OHamiltonian(bondLength, angle);
                }
            });
            
            // Обработчики для параметров H₂
            document.getElementById('h2-bond-length').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('h2-bond-length-value').textContent = `${value.toFixed(2)} Å`;
                qchem.calculateH2Hamiltonian(value);
            });
            
            document.getElementById('simulate-h2').addEventListener('click', function() {
                const bondLength = parseFloat(document.getElementById('h2-bond-length').value);
                qchem.calculateH2Hamiltonian(bondLength);
                qchem.showTooltip("Молекула H₂ рассчитана", 2000);
            });
            
            // Обработчики для параметров LiH
            document.getElementById('lih-bond-length').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('lih-bond-length-value').textContent = `${value.toFixed(2)} Å`;
                qchem.calculateLiHHamiltonian(value);
            });
            
            document.getElementById('simulate-lih').addEventListener('click', function() {
                const bondLength = parseFloat(document.getElementById('lih-bond-length').value);
                qchem.calculateLiHHamiltonian(bondLength);
                qchem.showTooltip("Молекула LiH рассчитана", 2000);
            });
            
            // Обработчики для параметров H₂O
            document.getElementById('h2o-bond-length').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('h2o-bond-length-value').textContent = `${value.toFixed(2)} Å`;
                const angle = parseFloat(document.getElementById('h2o-angle').value);
                qchem.calculateH2OHamiltonian(value, angle);
            });
            
            document.getElementById('h2o-angle').addEventListener('input', function() {
                const value = parseFloat(this.value);
                document.getElementById('h2o-angle-value').textContent = `${value.toFixed(1)}°`;
                const bondLength = parseFloat(document.getElementById('h2o-bond-length').value);
                qchem.calculateH2OHamiltonian(bondLength, value);
            });
            
            document.getElementById('simulate-h2o').addEventListener('click', function() {
                const bondLength = parseFloat(document.getElementById('h2o-bond-length').value);
                const angle = parseFloat(document.getElementById('h2o-angle').value);
                qchem.calculateH2OHamiltonian(bondLength, angle);
                qchem.showTooltip("Молекула H₂O рассчитана", 2000);
            });
            
            // Обработчик для кастомной молекулы
            document.getElementById('simulate-custom').addEventListener('click', function() {
                const hamiltonianText = document.getElementById('custom-hamiltonian').value;
                qchem.calculateCustomHamiltonian(hamiltonianText);
            });
            
            // Обработчик для запуска решателя
            document.getElementById('run-solver').addEventListener('click', function() {
                const method = document.getElementById('solver-method').value;
                
                if (method === 'exact') {
                    qchem.exactDiagonalization();
                    qchem.showTooltip("Точная диагонализация выполнена", 2000);
                } else if (method === 'vqe') {
                    qchem.runVQE();
                    qchem.showTooltip("VQE запущен...", 0);
                }
            });
            
            // Обработчики для переключения вкладок
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                });
            });
            
            // Обработчик для изменения метода решения
            document.getElementById('solver-method').addEventListener('change', function() {
                document.getElementById('vqe-params').style.display = 
                    this.value === 'vqe' ? 'block' : 'none';
            });
            
            // Инициализация по умолчанию
            qchem.calculateH2Hamiltonian(0.74);
        });
    </script>
</body>
</html>